<?php



/**
 * Implements hook_cron().
 */
//function exhibition_instagram_cron() {
//  exhibition_instagram_fetch_media();
//}


/**
 * Implements hook_cron_queue_info().
 *
 * Define our own "queue" item worked off by default system cron.
 */
function exhibition_instagram_cron_queue_info() {
//  $queues = array(
//    'exhibition_instagram' => array(
//      'worker callback' => 'exhibition_instagram_fetch_all',
//      'time' => 15, // default: 15 seconds.
//    ),
//  );
//  return $queues;
}


/**
 * Implements hook_menu().
 */
function exhibition_instagram_menu() {
  $items = array();
  $items['admin/content/instagram-import'] = array(
    'title' => 'Instagram Import',
    'description' => 'Trigger import of media from instagram',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('exhibition_instagram_import_form'),
    'access arguments' => array('administer content'),
    'type' => MENU_NORMAL_ITEM,
  );

  return $items;
}


/**
 * Form builder function to allow choice of which batch to be triggered.
 */
function exhibition_instagram_import_form() {
  $form['description'] = array(
    '#type' => 'markup',
    '#markup' => t('Import media from instagram feed.'),
  );
  $form['overrides'] = array(
    '#type' => 'fieldset',
    '#collapsible' => TRUE,
    '#collapsed' => TRUE,
    '#title' => t('Optional overrides'),
//    'limit_number' => array(
//      '#type' => 'textfield',
//      '#title' => t('Number of items'),
//      '#description' => t('Optional maximum number of items to import in this run.'),
//    ),
//    'lasttime' => array(
//      '#type' => 'textfield',
//      '#title' => t('Last time'),
//      '#description' => t('Optional UNIX timestamp to make _this_ import only consider content posted after that time. If not specified, the creation time stamp of the last previously imported content will be used by default (so donÂ´t worry).'),
//    ),
    'reset_lasttime' => array(
      '#type' => 'checkbox',
      '#title' => t('Reset last time'),
      '#description' => t('Reset last import time to start importing at the very beginning again.'),
    ),
  );
  $form['submit'] = array(
    '#type' => 'submit',
    '#value' => 'Start import',
  );

  return $form;
}


/**
 * Triggers instagram import batch on respective form submit.
 *
 * @param array $form
 *   Form API form.
 * @param array $form_state
 *   Form API form.
 */
function exhibition_instagram_import_form_submit($form, &$form_state) {
  // If requested, reset the import lasttime variable.
  if ($form_state['values']['reset_lasttime']) {
    variable_set('exhibition_instagram_lasttime', 0);
  }

  // Execute the function named exhibition_instagram_example_1 or exhibition_instagram_example_2.
  $batch = array(
    'title' => t('Importing from instagram'),
    'operations' => array(
      array('exhibition_instagram_import_batch_process', array()),
    ),
    'finished' => 'exhibition_instagram_import_batch_finished',
  );

  batch_set($batch);
}


/**
 * Import one batch of media from instagram.
 *
 * @param $context
 */
// More advanced example: multi-step operation - load all nodes, five by five
function exhibition_instagram_import_batch_process(&$context) {
  $max_bunches = variable_get('exhibition_instagram_max_bunches', 1);
  if (empty($context['sandbox'])) {
    $context['sandbox']['progress'] = 0;
    $context['sandbox']['max'] = 0;
  }
  $bunch_results = exhibition_instagram_fetch_bunch($context['sandbox']['progress']);

  // Progress / Finished?
  $context['sandbox']['progress']++;
  if ($context['sandbox']['progress'] >= $max_bunches) {
    drupal_set_message('Import stopped because limit of %max_bunches reached', array('%max_bunches' => $max_bunches));
    $context['finished'] = 1;
  }
  else if ($context['sandbox']['progress'] != $context['sandbox']['max']) {
    $context['finished'] = $context['sandbox']['progress'] / $context['sandbox']['max'];
  }
}


/**
 * Finishes the instagram import batch.
 */
function exhibition_instagram_example_finished($success, $results, $operations) {
  if ($success) {
    drupal_set_message(t('The final result was "%final"', array('%final' => end($results))));
  }
  else {
    // An error occurred.
    // $operations contains the operations that remained unprocessed.
    $error_operation = reset($operations);
    drupal_set_message(
      t('An error occurred while processing @operation with arguments : @args',
        array(
          '@operation' => $error_operation[0],
          '@args' => print_r($error_operation[0], TRUE),
        )
      )
    );
  }
}


/**
 * Fetches all outstanding media from the Instagram users feed.
 */
function exhibition_instagram_fetch_all() {
  exhibition_instagram_fetch_bunch(0, 0, 0);
}


/**
 * Fetches a bunch of outstanding media from the Instagram users feed.
 */
function exhibition_instagram_fetch_bunch($bunch_number = 0, $lasttime = 0, $limit_number = -1) {
  $return = array();
  $lasttime = $lasttime ? $lasttime : variable_get('exhibition_instagram_lasttime', 0);
  $limit_number = ($limit_number >= 0) ? $limit_number : variable_get('exhibition_instagram_limit', 1);

  $time_before_bunch = microtime();
  drupal_set_message(t('Importing bunch %bunch_number of max %limit_number instagram media starting at %lasttime', array('%bunch_number' => $bunch_number, '%limit_number' => $limit_number, '%lasttime' => $lasttime)));

  $instagram_user_id = variable_get('exhibition_instagram_user', 1820514626);
  $instagram_client_id = variable_get('exhibition_instagram_client', 'bd7b7ebede8845eda7bfd97bf7560887');
  $url = "https://api.instagram.com/v1/users/$instagram_user_id/media/recent/?client_id=$instagram_client_id&count=$limit_number&max_timestamp=$lasttime";

  $response = drupal_http_request($url);

  if ($response->code == 200) {
    $return['success'] = TRUE;
    $data = json_decode($response->data);

    if (!empty($data->data)) {
      foreach($data->data as $delta => $media) {
        variable_set('exhibition_instagram_lasttime', $media->created_time);
        $time_before = microtime();
        $node = exhibition_instagram_import_media($media);
        $m = "Import of media $bunch_number.$delta id " . $media->id . " ";
        if ($node) {
          $node_link = l('node ' . $node->nid, 'node/' . $node->nid);
          $m .= 'successful. ';
          if ($node->existing_entity) { $m .= 'UPDATED existing ' . $node_link; }
          else { $m .= 'CREATED new ' . $node_link; }
        }
        else {
          $m .= 'FAILED!';
        }
        $m .= ' (' . (microtime() - $time_before) .  'ms)';
        drupal_set_message($m, $node ? 'status' : 'error');
        watchdog('Instagram', $m, array(), $node ? WATCHDOG_INFO : WATCHDOG_ERROR);
      }
      $bunch_duration = microtime() - $time_before;
      $m = t("Bunch %bunch_number duration measured at (%bunch_duration ms).", array('%bunch_number' => $bunch_number, '%bunch_duration' => $bunch_duration));
      drupal_set_message($m);
      watchdog('instagram', $m);
    } else {
      $m = t("Bunch %bunch_number returned empty data result from instagram.");
      drupal_set_message($m);
      watchdog('instagram', $m);
    }
  }
  else {
    $return['success'] = FALSE;
    $return['error'] = 'Statuscode ' . $response->code . ' ("' . $response->status_message . '"). Error "' . $response->error . '"';
    drupal_set_message(t("Bunch %bunch_number failed, possibly retrying.", array('@bunch_number' => $bunch_number)));
  }
}


/**
 * Imports one given instagram media item as new visual node.
 */

function exhibition_instagram_import_media($media) {
  $result = FALSE;
  try {
    $captions = explode(variable_get('exhibition_instagram_caption_delimiter', '///'), $media->caption->text);

    $node = exhibition_instagram_get_entity('node', TRUE, array('field_imported_id' => array('value' => $media->id)), array(
      'type' => 'visual',
      'status' => 0,
      'language' => 'en',
      'title' => 'Instagram import ' . $media->id,
    ));
    $existing_node = isset($node->existing_entity) ? TRUE : FALSE;

    if (!$existing_node) {
      $node->status = 1;
      $node->translations->original = $node->language;
      $node->created = $node->updated = $media->created_time;
      $node->uid = $GLOBALS['user']->uid;
      $node->field_imported[LANGUAGE_NONE][0]['value'] = 1;
      $node->field_visual_purpose[LANGUAGE_NONE][0]['value'] = 'detail';
      $node->field_epoch[LANGUAGE_NONE][0]['tid'] = variable_get('exhibition_instagram_epoch_tid', 5); // "2015"
      $node->field_priority[LANGUAGE_NONE][0]['value'] = 0;
      $node->field_imported_id[LANGUAGE_NONE][0]['value'] = $media->id;
      $node->field_source[LANGUAGE_NONE][0]['title'] = 'everydaySrebrenica@Instagram';
      $node->field_source[LANGUAGE_NONE][0]['url'] = $media->link;
    }
    $node->field_imported_data[LANGUAGE_NONE][0]['value'] = json_encode($media);

    // Populate field_caption in EN and BS.
    foreach(array('en', 'bs') as $lang_delta => $lang_key) {
      $caption = isset($captions[$lang_delta]) ? $captions[$lang_delta] : '';

      // Remove hashtags in and from the caption itself.
      $caption = preg_replace('/#[\w\-.]+/', '', $caption);

      $node->field_visual_caption[$lang_key][0]['value'] = $caption;
      // Ensure translations are correctly managed.
      $node->translations->data[$lang_key] = array(
        'entity_type' => 'node',
        'entity_id' => $node->nid,
        'revision_id' => $node->vid,
        'language' => $lang_key,
        'source' => $node->translations->original,
        'uid' => $GLOBALS['user']->uid,
        'status' => 1,
        'translate' => 0,
        'created' => $media->created_time,
        'changed' => $media->created_time,
      );
    }

    // Import tags.
    $tag_vocabulary = taxonomy_vocabulary_machine_name_load('tag');
    $parent = FALSE;
    foreach ($media->tags as $tag) {
      $term = exhibition_instagram_get_entity('taxonomy_term', TRUE, array('name' => $tag, 'vid' => $tag_vocabulary->vid), array('bundle' => 'tag'));
      if (!isset($term->existing_entity)) {
        $m = 'New term ' . $term->tid . ' "' . $term->name. '" imported.';
        drupal_set_message($m);
        watchdog('instagram', $m);
      }
      $term->field_imported[LANGUAGE_NONE][0]['value'] = 1;
      taxonomy_term_save($term);
      // @Todo Avoid duplicate tags when running update-imports.
      $node->field_tag[LANGUAGE_NONE][]['tid'] = $term->tid;

      // Determine parent content from tag matching the tag configured on a portait node.
      if (!$parent) {
        $parent = exhibition_instagram_get_parent_by_import_tag($tag);
      }
    }

    // Store parent content relation.
    if (is_object($parent)) {
      $node->field_parent_content[LANGUAGE_NONE][0]['target_id'] = $parent->nid;
    }

    // Import image file for new imports.
    if (!isset($node->existing_entity)) {
      if (!empty($media->images->standard_resolution->url)) {
        $url = $media->images->standard_resolution->url;
        $local_file_path = 'public://field_image_file__imported';
        file_prepare_directory($local_file_path, FILE_CREATE_DIRECTORY);
        $local_file_path .= '/' . $node->nid . '--' . $media->id . '.jpg';
        $file_result = exhibition_instagram_store_file($url, $node, 'field_image_file', $local_file_path);
        if ($file_result) {
          $m = t('Successfully imported and stored file %url', array('%url' => $url));
          drupal_set_message($m);
          watchdog('instagram', $m);
        }
        else {
          $m = t('FAILED to import and store file %url', array('%url' => $url));
          drupal_set_message($m, 'error');
          watchdog('instagram', $m, array(), WATCHDOG_ERROR);
        }
      }
      else {
        if (!file_result) {
          $m = t('No image file for standard resolution found in instagram response for importing %media_id.', array('%media_id' => $media->id));
          drupal_set_message($m, 'error');
          watchdog('instagram', $m, array(), WATCHDOG_ERROR);
        }
      }
    }

    node_save($node);
    $result = $node;
  }
  catch (Exception $e) {
    watchdog_exception('instagram', $e);
    drupal_set_message('Exception: ' . $e->getMessage() . ' @ ' . $e->getFile() . ':' . $e->getLine(), 'error');
  }

  return $result;
}



/**
 * Gets an entity with given EFQ criteria or optionally creates one if none is found.
 *
 * Examples:
 *     $term = exhibition_instagram_get_entity('taxonomy_term', TRUE, array('name' => $tag, 'vid' => $tag_vocabulary->vid), array('bundle' => 'tag'));
 *
 *     $node = exhibition_instagram_get_entity('node', TRUE, array('field_imported_id' => array('value' => $id)), array(
 *       'type' => 'visual',
 *       'status' => 0,
 *       'language' => 'en',
 *       'title' => 'Instagram import ' . $media->id,
 *      ));
 */
function exhibition_instagram_get_entity($entity_type, $create_if_missing, $criteria, $defaults) {
  // Try to retrieve an existing entity matching the $criteria using an entity field query.
  $entity = FALSE;

  $query = new EntityFieldQuery();
  $query->entityCondition('entity_type', $entity_type)->range(0, 1);
  foreach($criteria as $criterion_key => $criterion_value) {
    // "field_*"-criterion => construct field condition.
    if ('field_' == substr($criterion_key, 0, 6)) {
      $criterion_value_field = reset(array_keys($criterion_value));
      $criterion_value_data  = reset($criterion_value);
      $query->fieldCondition($criterion_key, $criterion_value_field, $criterion_value_data);
    }
    // Property criterion => construct property condition.
    else {
      $defaults[$criterion_key] = $criterion_value;
      $query->propertyCondition($criterion_key, $criterion_value);
    }
  }

  $result = $query->execute();

  // If matching entity is found and returned, use that.
  if (isset($result[$entity_type])) {
    $entity = reset(entity_load($entity_type, array_keys($result[$entity_type])));
    $entity->existing_entity = TRUE;
  }
  else if ($create_if_missing) {
    // If no matching existing entity found, create new one.
    $entity = new stdClass();
    foreach ($defaults as $default_key => $default_value) {
      $entity->{$default_key} = $default_value;
    }

    // Special treatment for some entity types.
    if ('node' == $entity_type) {
      node_object_prepare($entity);
    }

    // Save entity to make it come alive and have its id set.
    entity_save($entity_type, $entity);
  }

  return $entity;
}


/**
 * Determine parent content from tag matching the tag configured on a portait node.
 */
function exhibition_instagram_get_parent_by_import_tag($tag) {
  static $parents_by_tag = array();

  if (!isset($parents_by_tag[$tag])) {
    $parent = exhibition_instagram_get_entity('node', FALSE, array('field_import_tag' => array('value' => $tag)));
    $parents_by_tag[$tag] = $parent;
  }

  return $parents_by_tag[$tag];
}


/**
 * Stores a remote file locally and assigns it to a given node and file/image field.
 */
function exhibition_instagram_store_file($url, &$node, $field_name, $local_file_path, $language = LANGUAGE_NONE) {
  $result = FALSE;
  $file_info = system_retrieve_file($url, $local_file_path, TRUE);
  if ($file_info->fid) {
    $result = TRUE;
    $node->{$field_name}[$language][]['fid'] = $file_info->fid;
    file_usage_add($file_info, 'file', 'node', $node->nid);
  }
  return $result;
}

