<?php


DEFINE('EXHIBITION_INSTAGRAM_USER', '1820514626');
DEFINE('EXHIBITION_INSTAGRAM_CLIENT', 'bd7b7ebede8845eda7bfd97bf7560887');
DEFINE('EXHIBITION_INSTAGRAM_RESULTS_PER_QUERY', 20);
DEFINE('EXHIBITION_INSTAGRAM_MAX_BUNCHES', 25);
DEFINE('EXHIBITION_INSTAGRAM_COUNT', 100);


/**
 * Implements hook_cron().
 */
//function exhibition_instagram_cron() {
//  exhibition_instagram_fetch_media();
//}


/**
 * Implements hook_cron_queue_info().
 *
 * Define our own "queue" item worked off by default system cron.
 */
function exhibition_instagram_cron_queue_info() {
//  $queues = array(
//    'exhibition_instagram' => array(
//      'worker callback' => 'exhibition_instagram_fetch_all',
//      'time' => 15, // default: 15 seconds.
//    ),
//  );
//  return $queues;
}


/**
 * Implements hook_menu().
 */
function exhibition_instagram_menu() {
  $items = array();
  $items['admin/content/instagram-import'] = array(
    'title' => 'Instagram Import',
    'description' => 'Trigger import of media from instagram',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('exhibition_instagram_import_form'),
    'access arguments' => array('administer content'),
    'type' => MENU_NORMAL_ITEM,
  );

  return $items;
}


/**
 * Form builder function to allow choice of which batch to be triggered.
 */
function exhibition_instagram_import_form() {
  $form['description'] = array(
    '#type' => 'markup',
    '#markup' => t('Import media from instagram feed.'),
  );
  $form['overrides'] = array(
    '#type' => 'fieldset',
    '#collapsible' => TRUE,
    '#collapsed' => TRUE,
    '#title' => t('Optional overrides'),
    'count' => array(
      '#type' => 'textfield',
      '#title' => t('Number of items'),
      '#description' => t('Optional maximum number of items to import in this run.'),
      '#default_value' => variable_get('exhibition_instagram_count', EXHIBITION_INSTAGRAM_COUNT),
    ),
    'max_id' => array(
      '#type' => 'textfield',
      '#title' => t('Max ID'),
      '#description' => t('Optional instagram post ID. If set, only posts prior to that are considered for import.'),
    ),
    'debug' => array(
      '#type' => 'checkbox',
      '#title' => t('Debug info'),
      '#description' => t('Display debug info.'),
    ),
    'dryrun' => array(
      '#type' => 'checkbox',
      '#title' => t('Dry Run'),
      '#description' => t('Simulate import as dry run (without actually creating content'),
    ),
  );
  $form['submit'] = array(
    '#type' => 'submit',
    '#value' => 'Start import',
  );

  return $form;
}


/**
 * Triggers instagram import batch on respective form submit.
 *
 * @param array $form
 *   Form API form.
 * @param array $form_state
 *   Form API form.
 */
function exhibition_instagram_import_form_submit($form, &$form_state) {
  // Execute the function named exhibition_instagram_example_1 or exhibition_instagram_example_2.
  $batch = array(
    'title' => t('Importing from instagram'),
    'operations' => array(
      array('exhibition_instagram_import_batch_process', array($form_state['values'])),
    ),
    'finished' => 'exhibition_instagram_batch_finished',
  );

  batch_set($batch);
}


/**
 * Displays and logs info.
 */
function exhibition_instagram_log($message, $arguments = array(), $error = FALSE, $debug_only = FALSE) {
  if (isset($GLOBALS['exhibition_instagram_log_debug_mode']) || !$debug_only) {
    drupal_set_message(t($message, $arguments), $error ? 'error' : 'status');
    watchdog('instagram', $message, $arguments, $error ? WATCHDOG_ERROR : WATCHDOG_INFO);
  }
}

/**
 * Import one batch of media from instagram.
 *
 * @param $context
 */
// More advanced example: multi-step operation - load all nodes, five by five
function exhibition_instagram_import_batch_process($overrides = array(), &$context) {
  if (empty($context['sandbox'])) {
    $context['sandbox']['progress'] = 1;
    $context['sandbox']['max_id'] = isset($overrides['max_id']) ? $overrides['max_id'] : FALSE;
    $context['sandbox']['count'] = isset($overrides['count']) ? $overrides['count'] : EXHIBITION_INSTAGRAM_COUNT;
    $context['sandbox']['bunches'] = ceil($context['sandbox']['count'] / EXHIBITION_INSTAGRAM_RESULTS_PER_QUERY);
  }
  else {
    $context['sandbox']['progress']++;
  }
  if ($overrides['debug']) {
    $GLOBALS['exhibition_instagram_log_debug_mode'] = TRUE;
  }
  if ($overrides['dryrun']) {
    $GLOBALS['exhibition_instagram_dryrun'] = TRUE;
  }

  $bunch_result = exhibition_instagram_fetch_bunch($context['sandbox']['progress'], $context['sandbox']['max_id'], $context['sandbox']['count']-count($context['results']));
  if ($GLOBALS['exhibition_instagram_log_debug_mode']) { dpm($bunch_result['imported'], 'batch $bunch_result[imported]'); }
  $context['results'] = array_merge($context['results'], $bunch_result['imported']);
  $context['sandbox']['max_id'] = $bunch_result['max_id'];

  // Progress / Finished?
  if ($context['sandbox']['progress'] > EXHIBITION_INSTAGRAM_MAX_BUNCHES) {
    exhibition_instagram_log('Import stopped because limit of %max_bunches bunches reached', array('%max_bunches' => EXHIBITION_INSTAGRAM_MAX_BUNCHES), FALSE, TRUE);
    $context['finished'] = 1;
  }
  else if (!$bunch_result['result_count']) {
    exhibition_instagram_log('Empty instagram response for bunch %bunch => we stop import here.', array('%bunch' => $context['sandbox']['progress']), FALSE, TRUE);
    $context['finished'] = 1;
  }
  else {
    $context['finished'] = count($context['results']) / $context['sandbox']['count'];
  }

  $context['message'] = t('Found and imported %results of %max_results', array('%results' => count($context['results']), '%max_results' => $context['sandbox']['count']));
  if ($GLOBALS['exhibition_instagram_log_debug_mode']) { dpm($context, 'batch $context'); }
}

/**
 * Finishes the instagram import batch.
 */
function exhibition_instagram_batch_finished($success, $results, $operations) {
  if ($success) {
    exhibition_instagram_log("Imported %num posts", array('%num' => count($results)));
    foreach($results as $result) {
      exhibition_instagram_log($result);
    }
  }
  else {
    // An error occurred.
    // $operations contains the operations that remained unprocessed.
    $error_operation = reset($operations);
    exhibition_instagram_log('An error occurred while processing @operation with arguments : @args', array('@operation' => $error_operation[0], '@args' => print_r($error_operation[0], TRUE)), TRUE);
  }
}


/**
 * Fetches all outstanding media from the Instagram users feed.
 */
function exhibition_instagram_fetch() {
  $max = variable_get('exhibition_instagram_count', EXHIBITION_INSTAGRAM_COUNT);
  for ($i = 1; $i <= $max; $i++) {
    $bunch_result = exhibition_instagram_fetch_bunch($i);
  }
}


/**
 * Fetches a bunch of outstanding media from the Instagram users feed.
 */
function exhibition_instagram_fetch_bunch($bunch_number = 0, $max_id = FALSE, $max_count = 0) {
  $return = array(
    'success' => FALSE,
    'max_id' => FALSE,
    'imported' => array(),
    'result_count' => 0,
  );
  if (!$max_count) { $max_count = EXHIBITION_INSTAGRAM_RESULTS_PER_QUERY; }

  $time_before_bunch = microtime();
  exhibition_instagram_log('Importing bunch %bunch_number of max %limit_number instagram media starting at id %max_id', array('%bunch_number' => $bunch_number, '%limit_number' => EXHIBITION_INSTAGRAM_RESULTS_PER_QUERY, '%max_id' => $max_id), FALSE, TRUE);

  $instagram_user_id = variable_get('exhibition_instagram_user', EXHIBITION_INSTAGRAM_USER);
  $instagram_client_id = variable_get('exhibition_instagram_client', EXHIBITION_INSTAGRAM_CLIENT);
  $url = "https://api.instagram.com/v1/users/$instagram_user_id/media/recent/?client_id=$instagram_client_id";
  if ($max_id) {
    $url .= '&max_id=' . $max_id;
  }

  $response = drupal_http_request($url);

  if ($response->code == 200) {
    $return['success'] = TRUE;
    $data = json_decode($response->data);

    if (!empty($data->data)) {
      $return['result_count'] = count($data->data);
      foreach($data->data as $delta => $media) {
        if ($max_count > 0) {
          $return['max_id'] = $media->id;
          $time_before = microtime();
          $node = exhibition_instagram_import_media($media);
          $m = "Import of media $bunch_number.$delta id " . $media->id . " ";
          if (is_object($node)) {
            $max_count--;
            $node_link = l('node ' . $node->nid, 'node/' . $node->nid);
            $m .= 'SUCCESSFUL. ';
            $return['imported'][] = $node->title;
            if ($node->existing_entity) {
              $m .= 'UPDATED existing ' . $node_link;
            }
            else {
              $m .= 'CREATED new ' . $node_link;
            }
          }
          else {
            $m .= $node ? 'SKIPPED' : 'FAILED!';
          }
          $m .= ' (' . (microtime() - $time_before) .  'ms)';
          exhibition_instagram_log($m, array(), (FALSE === $node), TRUE);
        }
      }
      exhibition_instagram_log('Bunch %bunch_number duration measured at (%bunch_duration ms).', array('%bunch_number' => $bunch_number, '%bunch_duration' => microtime() - $time_before), FALSE, TRUE);
    } else {
      exhibition_instagram_log('Bunch %bunch_number returned empty data result from instagram.', array('%bunch_number' => $bunch_number), FALSE, TRUE);
    }
  }
  else {
    $return['success'] = FALSE;
    $return['error'] = 'Statuscode ' . $response->code . ' ("' . $response->status_message . '"). Error "' . $response->error . '"';
    exhibition_instagram_log('Bunch %bunch_number failed.', array('@bunch_number' => $bunch_number), TRUE, TRUE);
  }

  return $return;
}


/**
 * Imports one given instagram media item as new visual node.
 */

function exhibition_instagram_import_media($media) {
  $result = FALSE;
  try {
    // Determine parent content relationship from tag matching the tag configured on a portait node.
    $parent = FALSE;
    foreach ($media->tags as $tag) {
      if (!$parent) {
        $parent = exhibition_instagram_get_parent_by_import_tag($tag);
      }
    }

    // Only look further if this item has a parent relationship.
    if (is_object($parent)) {
      $node_title = '@' . $parent->title . ' - Instagram import ' . $media->id;
      if (isset($GLOBALS['exhibition_instagram_dryrun'])) {
        $dummy = new stdClass();
        $dummy->title = $node_title;
        return $dummy;
      }
      // Split up captions.
      $captions = explode(variable_get('exhibition_instagram_caption_delimiter', '///'), $media->caption->text);

      // Try to find existing node.
      $node = exhibition_instagram_get_entity('node', TRUE, array('field_imported_id' => array('value' => $media->id)), array(
        'type' => 'visual',
        'status' => 0,
        'language' => 'en',
        'title' => $node_title,
      ));
      $existing_node = isset($node->existing_entity);

      // Fill fields.
      if (!$existing_node) {
        $node->importing = TRUE;
        $node->status = 1;
        $node->translations->original = $node->language;
        $node->created = $node->modified = $media->created_time;
        $node->uid = $GLOBALS['user']->uid;
        $node->field_imported[LANGUAGE_NONE][0]['value'] = 1;
        $node->field_visual_purpose[LANGUAGE_NONE][0]['value'] = 'detail';
        $node->field_epoch[LANGUAGE_NONE][0]['tid'] = variable_get('exhibition_instagram_epoch_tid', 5); // "2015"
        $node->field_priority[LANGUAGE_NONE][0]['value'] = 0;
        $node->field_imported_id[LANGUAGE_NONE][0]['value'] = $media->id;
        $node->field_imported_time[LANGUAGE_NONE][0]['value'] = REQUEST_TIME;
        $node->field_source[LANGUAGE_NONE][0]['title'] = 'everydaySrebrenica@Instagram';
        $node->field_source[LANGUAGE_NONE][0]['url'] = $media->link;
      }
      $node->field_imported_data[LANGUAGE_NONE][0]['value'] = json_encode($media);
      $node->field_parent_content[LANGUAGE_NONE][0]['target_id'] = $parent->nid;

      // Populate field_caption in EN and BS.
      foreach(array('en', 'bs') as $lang_delta => $lang_key) {
        $caption = isset($captions[$lang_delta]) ? $captions[$lang_delta] : '';

        // Remove hashtags in and from the caption itself.
        $caption = preg_replace('/#[\w\-.]+/', '', $caption);

        $node->field_visual_caption[$lang_key][0]['value'] = $caption;
        // Ensure translations are correctly managed.
        $node->translations->data[$lang_key] = array(
          'entity_type' => 'node',
          'entity_id' => $node->nid,
          'revision_id' => $node->vid,
          'language' => $lang_key,
          'source' => $node->language,
          'uid' => $GLOBALS['user']->uid,
          'status' => 1,
          'translate' => 0,
          'created' => $media->created_time,
          'changed' => $media->created_time,
        );
      }

      // Import tags.
      $tag_vocabulary = taxonomy_vocabulary_machine_name_load('tag');
      foreach ($media->tags as $tag) {
        $term = exhibition_instagram_get_entity('taxonomy_term', TRUE, array('name' => $tag, 'vid' => $tag_vocabulary->vid), array('bundle' => 'tag'));
        if (!isset($term->existing_entity)) {
          exhibition_instagram_log('New term %tid "%name" imported.', array('%tid' => $term->tid, '%name' => $term->name), FALSE, TRUE);
        }
        $term->field_imported[LANGUAGE_NONE][0]['value'] = 1;
        taxonomy_term_save($term);
        // @Todo Avoid duplicate tags when running update-imports.
        $node->field_tag[LANGUAGE_NONE][]['tid'] = $term->tid;
      }

      // Import image file for new imports.
      if (!isset($node->existing_entity)) {
        if (!empty($media->images->standard_resolution->url)) {
          $url = $media->images->standard_resolution->url;
          $local_file_path = 'public://field_image_file__imported';
          file_prepare_directory($local_file_path, FILE_CREATE_DIRECTORY);
          $local_file_path .= '/' . $node->nid . '--' . $media->id . '.jpg';
          $file_result = exhibition_instagram_store_file($url, $node, 'field_image_file', $local_file_path);
          if ($file_result) {
            exhibition_instagram_log('Successfully imported and stored file %url.', array('%url' => $url), FALSE, TRUE);
          }
          else {
            exhibition_instagram_log('FAILED to import and store file %url', array('%url' => $url), TRUE, TRUE);
          }
        }
        else {
          if (!file_result) {
            exhibition_instagram_log('No image file for standard resolution found in instagram response for importing %media_id.', array('%media_id' => $media->id), TRUE, TRUE);
          }
        }
      }

      node_save($node);
      $result = $node;
    }
    // (If no parent relationship found).
    else {
      $result = TRUE;
    }
  }
  catch (Exception $e) {
    watchdog_exception('instagram', $e);
    exhibition_instagram_log('Exception: ' . $e->getMessage() . ' @ ' . $e->getFile() . ':' . $e->getLine(), array(), TRUE, FALSE);
  }

  return $result;
}



/**
 * Gets an entity with given EFQ criteria or optionally creates one if none is found.
 *
 * Examples:
 *     $term = exhibition_instagram_get_entity('taxonomy_term', TRUE, array('name' => $tag, 'vid' => $tag_vocabulary->vid), array('bundle' => 'tag'));
 *
 *     $node = exhibition_instagram_get_entity('node', TRUE, array('field_imported_id' => array('value' => $id)), array(
 *       'type' => 'visual',
 *       'status' => 0,
 *       'language' => 'en',
 *       'title' => 'Instagram import ' . $media->id,
 *      ));
 */
function exhibition_instagram_get_entity($entity_type, $create_if_missing, $criteria, $defaults) {
  // Try to retrieve an existing entity matching the $criteria using an entity field query.
  $entity = FALSE;

  $query = new EntityFieldQuery();
  $query->entityCondition('entity_type', $entity_type)->range(0, 1);
  foreach($criteria as $criterion_key => $criterion_value) {
    // "field_*"-criterion => construct field condition.
    if ('field_' == substr($criterion_key, 0, 6)) {
      $criterion_value_field = reset(array_keys($criterion_value));
      $criterion_value_data  = reset($criterion_value);
      $query->fieldCondition($criterion_key, $criterion_value_field, $criterion_value_data);
    }
    // Property criterion => construct property condition.
    else {
      $defaults[$criterion_key] = $criterion_value;
      $query->propertyCondition($criterion_key, $criterion_value);
    }
  }

  $result = $query->execute();

  // If matching entity is found and returned, use that.
  if (isset($result[$entity_type])) {
    $entity = reset(entity_load($entity_type, array_keys($result[$entity_type])));
    $entity->existing_entity = TRUE;
  }
  else if ($create_if_missing) {
    // If no matching existing entity found, create new one.
    $entity = new stdClass();
    foreach ($defaults as $default_key => $default_value) {
      $entity->{$default_key} = $default_value;
    }

    // Special treatment for some entity types.
    if ('node' == $entity_type) {
      node_object_prepare($entity);
    }

    // Save entity to make it come alive and have its id set.
    entity_save($entity_type, $entity);
  }

  return $entity;
}


/**
 * Determine parent content from tag matching the tag configured on a portait node.
 */
function exhibition_instagram_get_parent_by_import_tag($tag) {
  static $parents_by_tag = array();

  if (!isset($parents_by_tag[$tag])) {
    $parent = exhibition_instagram_get_entity('node', FALSE, array('field_import_tag' => array('value' => $tag)));
    $parents_by_tag[$tag] = $parent;
  }

  return $parents_by_tag[$tag];
}


/**
 * Stores a remote file locally and assigns it to a given node and file/image field.
 */
function exhibition_instagram_store_file($url, &$node, $field_name, $local_file_path, $language = LANGUAGE_NONE) {
  $result = FALSE;
  $file_info = system_retrieve_file($url, $local_file_path, TRUE);
  if ($file_info->fid) {
    $result = $file_info;
    $node->{$field_name}[$language][]['fid'] = $file_info->fid;
    file_usage_add($file_info, 'file', 'node', $node->nid);
  }
  return $result;
}


/**
 * Implements hook_node_presave().
 */
function exhibition_instagram_node_presave(&$node) {
  if (isset($node->importing)) {
    $node->changed = $node->modified;
  }
}


